// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// This file is specifically generated for
//   Date: 09-Jan, 2007

// OTLib 3.2 is customized with the following options:
// * Interrupt Mode of operation (Attention Line)
// * Software I2C on the host processor
// * Button  Features on OneTouch
// * TimeOut For the Attention Line  
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Copyright (c) 2006-2007 Synaptics, Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in 
// the Software without restriction, including without limitation the rights to use, 
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the 
// Software, and to permit persons to whom the Software is furnished to do so, 
// subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all 
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
// SOFTWARE.
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// This file implements the OTLib functions that the customer application code calls
//
//	  - The functions are hardware independent, however depends on the Hardware 
//		Abstract Layer function calls
//    - The code/ library should be able to run on any host processor
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 
// ******************************************
// ******************************************
// ==> WARNING: ** DO NOT EDIT This file <== 
// ******************************************
// ******************************************
 
#include "SynaOT.h"
#include "UserOT.h"
#include <linux/kernel.h>
#include <linux/delay.h>
#include <asm/arch/37xx/regs.h>
#include <asm/arch/37xx/regsdigctl.h>
#include <asm/arch/37xx/regslradc.h>
#include <asm/arch/37xx/regspinctrl.h>
#include <asm-arm/arch-stmp37xx/gpio.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/input.h>
#include <linux/device.h>
#include <linux/platform_device.h>
#include <linux/clk.h>
#include <linux/err.h>
#include <linux/errno.h>
#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>
#include <linux/types.h>
#include <linux/fcntl.h>
#include <linux/sched.h>
#include <linux/fs.h>
#include <linux/proc_fs.h>
#include <linux/delay.h>
#include <linux/spinlock.h>
#include <linux/time.h>
#include <linux/timer.h>
#include <linux/input.h>
#include <linux/irq.h>
#include <asm/io.h>
#include <asm/irq.h>
#include <asm/arch/irqs.h>
#include <asm/uaccess.h>
#include <asm/hardware.h>
#include <asm/arch/stmp37xx_pm.h>
#include <asm/arch/digctl.h>
#include <asm/arch/hardware.h>
#include <asm/arch/usb_common.h>

// =========================
// * defines and constants *
// =========================

#define OT_READ		0x01	// I2C READ bit

// delays and timing routines

#if 0
// I2C 4 usec delay
#define OT_QDEL	OT_HAL_delay_10th_usec(4); //40); //add dhsong for adjusting delay		
// I2C 4.7usec delay
#define OT_HDEL	OT_HAL_delay_10th_usec(5); //47);

// minimum time SCL must remain low while clocking a data bit
#define	OT_I2C_TLOW_DELAY         	OT_HAL_delay_10th_usec(5); //47);
// minimum time SCL must remain high while clocking a data bit
#define	OT_I2C_THIGH_DELAY        	OT_HAL_delay_10th_usec(4); //40);
// minimum time SCL must remain low after a stop condition
#define	OT_I2C_TBUF_DELAY         	OT_HAL_delay_10th_usec(5); //47);
// Repeated Start condition setup time
#define	OT_I2C_TSU_STA_DELAY      	OT_HAL_delay_10th_usec(5); //47);
// Start condition hold time
#define	OT_I2C_THD_STA_DELAY      	OT_HAL_delay_10th_usec(4); //40);
// Stop condition setup time
#define	OT_I2C_TSU_STO_DELAY      	OT_HAL_delay_10th_usec(4); //40);
#else
// I2C 2 usec delay
#define OT_QDEL	OT_HAL_delay_10th_usec(2); //40); //add dhsong for adjusting delay		
// I2C 3 usec delay
#define OT_HDEL	OT_HAL_delay_10th_usec(3); //47);

// minimum time SCL must remain low while clocking a data bit
#define	OT_I2C_TLOW_DELAY         	OT_HAL_delay_10th_usec(3); //47);
// minimum time SCL must remain high while clocking a data bit
#define	OT_I2C_THIGH_DELAY        	OT_HAL_delay_10th_usec(2); //40);
// minimum time SCL must remain low after a stop condition
#define	OT_I2C_TBUF_DELAY         	OT_HAL_delay_10th_usec(3); //47);
// Repeated Start condition setup time
#define	OT_I2C_TSU_STA_DELAY      	OT_HAL_delay_10th_usec(3); //47);
// Start condition hold time
#define	OT_I2C_THD_STA_DELAY      	OT_HAL_delay_10th_usec(2); //40);
// Stop condition setup time
#define	OT_I2C_TSU_STO_DELAY      	OT_HAL_delay_10th_usec(2); //40);

#endif //#if 0

unsigned int init_enable = 1;

//*****************************************************
//* I2C Bit Banging Host Processor Independent functions *
//*****************************************************

void  OT_SDA_HIGH(void);
void  OT_SCL_HIGH(void);

void  OT_SDA_LOW(void);
void  OT_SCL_LOW(void);

void	OT_I2C_SCL_TOGGLE(void);
void	OT_I2C_START(void);
void	OT_I2C_STOP(void);


//**********************************
//* I2C Byte Read/ Write functions *
//**********************************

// Put a Byte on the I2C bus line
// return OT_SUCCESS (ACK), or OT_FAILURE (NACK)
OT_U8 OT_I2C_PutByte(OT_U8 bByte);

// Get a Byte on the I2C bus line
OT_U8 OT_I2C_GetByte(OT_U8 bLast);




//*****************************
//* I2C Bit Banging functions *
//*****************************

void  OT_I2C_SCL_TOGGLE(void)
{
	OT_HDEL; 
	OT_SCL_HIGH(); 
	OT_HDEL; 
	OT_SCL_LOW(); 
}

void  OT_I2C_START(void)
{
	OT_SDA_LOW();
	OT_QDEL; 
	OT_SCL_LOW(); 
}

void  OT_I2C_STOP(void)
{
	OT_SDA_LOW();
	OT_HDEL; 
	OT_SCL_HIGH(); 
	OT_QDEL; 
	OT_SDA_HIGH(); 
	OT_HDEL;
}

// Set I2C Data Line as Low
void  OT_SDA_LOW(void)
{
	OT_HAL_SDA_OUT_MODE();
	OT_HAL_I2C_SDA_LO();
}

// Set I2C Clock Line as Low
void  OT_SCL_LOW(void)
{
	OT_HAL_SCL_OUT_MODE();
	OT_HAL_I2C_SCL_LO();
}

// Set I2C Data Line as High
void  OT_SDA_HIGH(void)
{
	OT_HAL_SDA_IN_MODE();
}


// Set I2C Clock Line as High, with clock stretching
// The clock stretching time out is approximately 0 usec

void  OT_SCL_HIGH(void)
{
	static unsigned int start_time=0;
        static unsigned int end_time=0;

	OT_S32 bDelay = OT_HAL_CLK_STRETCH_LIMIT;		
	//unsigned char read_data = 0;
		
	OT_HAL_SCL_IN_MODE();
		//printk("HW_PINCTRL_DOE0=0x%08x\n", HW_PINCTRL_DOE0);
#if 1	
	//start_time = HW_RTC_MILLISECONDS_RD();	
	while( (OT_HAL_BitRead_I2C_SCL() == 0) && (bDelay >= 0) )
	//while( ( (HW_PINCTRL_DIN0_RD() >> 18) & 0x00000001 == 0) && (bDelay >= 0) ) //add dhsong
	{
		
	//	printk("HW_PINCTRL_DIN0=0x%08x\n", HW_PINCTRL_DIN0);
		bDelay--;
	}
	if(bDelay < 0)
		; //printk("bDelay = %d\n", bDelay);
		
	//printk("HW_PINCTRL_DIN0=0x%08x\n", HW_PINCTRL_DIN0_RD() >> 18 & 0x00000001);
	//end_time = HW_RTC_MILLISECONDS_RD();
        //printk("mdelay = %d\n", end_time - start_time);
	
	//printk("bDelay = %d\n\n", bDelay);	
#else
	udelay(2000);
#endif
	// decide on if error needs to be returned!
}


//**********************************
//* I2C Byte Read/ Write functions *
//**********************************

// Put a Byte on the I2C bus line
// return OT_SUCCESS (ACK), or OT_FAILURE (NACK)

OT_U8 OT_I2C_PutByte(OT_U8 Byte)
{
	OT_S8 Counter;		
	
	for (Counter=7; Counter>= 0; Counter--)
	{
		if ( Byte & (1<<Counter) )
		{
			OT_SDA_HIGH();
		}
		else
		{			
			OT_SDA_LOW();			// address bit
		}
		
		OT_I2C_SCL_TOGGLE();		// clock HI, delay, then LO
	}

	OT_SDA_HIGH();					// leave SDA HI
	
	OT_HDEL;
	OT_SCL_HIGH();					// clock back up
	OT_HDEL;
	
	//udelay(30); //dhsong
	Byte=OT_HAL_BitRead_I2C_SDA();	// get the ACK bit

	OT_SCL_LOW();
	OT_SDA_HIGH();					// leave with SDA HI

	if(Byte == 0)
			return OT_SUCCESS;		// return OT_SUCCESS (ACK), or OT_FAILURE (NACK)
	
	return OT_FAILURE;
}

// Get a Byte on the I2C bus line
OT_U8 OT_I2C_GetByte(OT_U8 Last)
{
	OT_S8 Counter;
	OT_U8 Val,Byte = 0;
		
	OT_SDA_HIGH();					// make sure pullups are ativated

	for(Counter=7; Counter>=0; Counter--)
	{
		OT_HDEL;
		OT_SCL_HIGH();				// clock HI
		
		//udelay(30); //add dhsong
	
		Val=OT_HAL_BitRead_I2C_SDA();	  	 
		Byte <<= 1;
		if(Val) Byte |= 1;
		OT_HDEL;		
		OT_SCL_LOW();				// clock LO
	}
  
	if (Last)
		OT_SDA_HIGH();				// set NAK
	else
		OT_SDA_LOW();				// set ACK

	OT_I2C_SCL_TOGGLE();			// clock pulse
	OT_SDA_HIGH();					// leave with SDL HI


	return Byte;					// return received byte

			// Return error code (needs investigation)
}


// ========================
// * I2C public functions *
// ========================

// Initialize I2C communication
void OT_Init_BitBang_I2C(void)
{
	
	OT_SCL_HIGH();
	OT_SDA_HIGH();
	
}

// ========================================================================
// This is a function to Send a Byte sequence on the I2C bus
//
// Functions Name:
//  * OT_WriteI2C()
//
// Inputs: (
//  * I2CAddr7Bit, (7-bit I2C Device Address)
//  * Buffer (Buffer of bytes to be written)
// 		- High Byte of subaddress andthe Low Byte of subaddress
//		- are the first two bytes of pBuffer[]
//  * BytesToSend (No. of Bytes to write)
//
// Outputs:
//	Returns OT_SUCCESS or OT_FAILURE
//
// Assumptions:	
//	 The High Byte of subaddress and the Low Byte of subaddress
// 	 are the first two bytes of Buffer[]
// ========================================================================

OT_U8 OT_WriteI2C(OT_U8 I2CAddr7Bit, OT_U8 Buffer[], OT_U8 BytesToSend)		
{
	OT_U8 Count=0;
	
//		printk("%s, %d\n", __FILE__, __LINE__);
	OT_I2C_START();      			// do start transition
//		printk("%s, %d\n", __FILE__, __LINE__);

	if(OT_I2C_PutByte(I2CAddr7Bit<<1)== OT_FAILURE)	// send DEVICE address
	{
		OT_I2C_STOP();					// send STOP transition
		return OT_FAILURE;		// no bytes are written
	}
	
//		printk("%s, %d\n", __FILE__, __LINE__);
	//	the High Byte of subaddress and the Low Byte of subaddress
	// 	are the first two bytes of Buffer[]
	
	// send the data
	while (Count < BytesToSend)
	{
//		printk("%s, %d\n", __FILE__, __LINE__);
		if(OT_I2C_PutByte(Buffer[Count++]) == OT_FAILURE)
		{
			printk("OT_I2C_PutByte Fail, %s, %d\n", __FILE__, __LINE__);
			OT_I2C_STOP();					// send STOP transition
			return OT_FAILURE;
		}
//		printk("%s, %d\n", __FILE__, __LINE__);
	}

//		printk("%s, %d\n", __FILE__, __LINE__);
	OT_I2C_STOP();					// send STOP transition
//		printk("%s, %d\n", __FILE__, __LINE__);
	
	return OT_SUCCESS;
}


// ============================================================================
// This is a function to Read a Byte sequence on the I2C bus
//
// Functions Name:
//  * OT_ReadI2C()
//
// Inputs: (
//  * I2CAddr7Bit, (7-bit I2C Device Address)
//  * Buffer (Buffer of bytes to be read)
//  * BytesToSend (No. of Bytes to be read)
//
// Outputs:
//  	Returns OT_SUCCESS or OT_FAILURE
//	
// Assumptions:
//		It is assumed the High Byte and the Low Byte of subaddress are pre-set	
// ==============================================================================

OT_U8 OT_ReadI2C(OT_U8 I2CAddr7Bit, OT_U8 Buffer[], OT_U8 BytesToRead)
{
	OT_U8 Count=0;

	OT_I2C_START();					// do start transition

	// It is assumed the High Byte and the Low Byte of subaddress are pre-set
	
	if(OT_I2C_PutByte(I2CAddr7Bit<<1 | OT_READ) == OT_FAILURE) //send DEVICE address, with READ bit set
	{
		OT_I2C_STOP();					// send STOP transition
		return OT_FAILURE;
	}
	
	// receive data bytes

	while (Count < BytesToRead)
		{
			Buffer[Count] = OT_I2C_GetByte(Count == (BytesToRead-1));
			Count++;
		}

	OT_I2C_STOP();					// send STOP transition
	
	return OT_SUCCESS;		
			
			// instead of always returning success, investigage to return various error codes
}

// End of OT_BITBANG_I2C_MASTER Routines
	


	// End of OT_USE_DEFAULT_ATTN_WATCHER


// *****************************************************************************
// This is a function to Set ReadAddress of OneTouch Data registers
//
// Functions Name:
// * OT_Set_ReadAddress()
//
// Inputs:				
// * None
//
// Outputs:
//		Error Code		// ToDo: OT_Success or OT_FAIL
//	
// Dependencies:
//		OT_WriteI2C();
//
// Note:	All dependencies are hardware dependent and implemented in the
//			Hardware Abstraction Layer (HAL) of the host application code
// *****************************************************************************

OT_U8 OT_write_ReadAddress(unsigned char high, unsigned char low) //add dhsong
{
	OT_U8 pReg_data[2];
	
	pReg_data[0]	=	high;
	pReg_data[1]	=	low;
	
	return OT_WriteI2C(OT_ADDR,pReg_data,2);
		
}

OT_U8 OT_Set_ReadAddress(void) //read only reg 0x0109	
{
	OT_U8 pReg[2];
	
	pReg[0]	=	OT_DATA_REG_START_ADDR_HIGH;
	pReg[1]	=	OT_DATA_REG_START_ADDR_LOW;
	
	return OT_WriteI2C(OT_ADDR,pReg,2);
}

OT_U8 OT_touchpad_read(OT_U8 *dum_pBuffer, OT_U8 high_data, OT_U8 low_data) //dhsong
{
	//unsigned char dum_pBuffer[2];

	gpio_init();

	OT_Init_BitBang_I2C();

        if(OT_write_ReadAddress(high_data, low_data) == OT_FAILURE) {
                printk("OT_write_ReadAddress Fail, %s, %d\n", __FILE__, __LINE__);
                return OT_FAILURE;
        }
                //printk("%s, %d\n", __FILE__, __LINE__);
	
// read the data register to deassert the attention line
 	return OT_ReadI2C(OT_ADDR,dum_pBuffer,2);
}

OT_U8 OT_touchpad_write(unsigned char *data, unsigned int length) //dhsong
{
#if 0
	OT_U8 pReg[4];
	
	pReg[0]	=	0x00;
	pReg[1]	=	0x01;
	pReg[2]	=	0x00;
	pReg[3]	=	0x28;
#endif
	gpio_init();
	OT_set_base_addr();
	
	if(OT_WriteI2C(OT_ADDR, data, length)== OT_FAILURE) {
		printk("OT_WriteI2C Fail, %s, %d\n", __FILE__, __LINE__);
		return OT_FAILURE;	// write to config failed
	}
}

OT_U8 OT_set_base_addr(void) //add dhsong
{
	OT_U8  pBuffer[2];
	unsigned int bTemp;				

// set base address			
	if(OT_Set_ReadAddress() == OT_FAILURE) {
		//printk("%s, %d\n", __FILE__, __LINE__);
		return OT_FAILURE;		
	}					
		//printk("%s, %d\n", __FILE__, __LINE__);

// read the data register to deassert the attention line
		return OT_ReadI2C(OT_ADDR,pBuffer,2);
}

// *****************************************************************************
// This is a function to Initialize the OneTouch hardware interface
//
// Functions Name:
//  * OT_Init()
//
// Inputs: 
//  * None
//
// Outputs:
//  * The Error Code (or success code). "Refer to SynaOT.h
// 
// Dependencies:
//  * OT_HAL_BitRead_ATTN();
//  * OT_ReadI2C();
//  * OT_WriteI2C();
//
// Note:	All dependencies are hardware dependent and implemented in the
//			Hardware Abstraction Layer (HAL) of the host application code
// *****************************************************************************


OT_U8 OT_Init(void)
{	

	OT_U8  pBuffer[OT_NUM_CONFIG_BYTES];
	unsigned int bTemp;				
#if 1
	// wait for attention line with timeout
	// Customer Implements OT_Poll_Attn_Line_TimeOut(),
	// if not implemented, there is no timeout								
//	printk("%s, %d\n", __FILE__, __LINE__);
	if(OT_Poll_Attn_Line_TimeOut() == OT_FAILURE) {
		printk("OT_Poll_Attn_Line_TimeOut Fail, %s, %d\n", __FILE__, __LINE__);
		return OT_FAILURE;
	}
		//printk("%s, %d\n", __FILE__, __LINE__);
	
//	Write the configuration to the OneTouch
	if(OT_WriteI2C(OT_ADDR, g_OT_Config, OT_NUM_CONFIG_BYTES)== OT_FAILURE) {
		printk("OT_WriteI2C Fail, %s, %d\n", __FILE__, __LINE__);
		return OT_FAILURE;	// write to config failed
	}
		//printk("%s, %d\n", __FILE__, __LINE__);
	
// read the entire configuration back from the device			
	if(OT_ReadI2C(OT_ADDR, pBuffer,(OT_NUM_CONFIG_BYTES-2)) == OT_FAILURE) {
		printk("OT_ReadI2C Fail, %s, %d\n", __FILE__, __LINE__);
		return OT_FAILURE;
	}
// verify the configuration registers are written correctly
	for(bTemp=0; bTemp < (OT_NUM_CONFIG_BYTES-2); bTemp++) {
		//printk("pBuffer[%d] = 0x%08x\n", bTemp, pBuffer[bTemp]);
		if(pBuffer[bTemp] != g_OT_Config[bTemp+2]) {
				printk("Read, write test Fail, %s, %d\n", __FILE__, __LINE__);
				return OT_FAILURE;	
		}	
	}
		//printk("%s, %d\n", __FILE__, __LINE__);
				
// set base address			
	if(OT_Set_ReadAddress() == OT_FAILURE) {
		printk("OT_Set_ReadAddress Fail, %s, %d\n", __FILE__, __LINE__);
		return OT_FAILURE;		
	}					
		//printk("%s, %d\n", __FILE__, __LINE__);

// read the data register to deassert the attention line
		return OT_ReadI2C(OT_ADDR,pBuffer,2);
#else

 #define PIN_SCL BANK0_PIN18
 #define GET_TOUCHPAD_SCL2             stmp37xx_gpio_get_level(PIN_SCL)

	OT_HAL_SCL_OUT_MODE();
	OT_HAL_I2C_SCL_LO();
	udelay(2000);
	printk("level = %d\n", GET_TOUCHPAD_SCL2);
	OT_HAL_SCL_IN_MODE();
	udelay(2000);
	printk("level = %d\n", GET_TOUCHPAD_SCL2);
	
	
	OT_HAL_SCL_OUT_MODE();
	OT_HAL_I2C_SCL_LO();
	udelay(2000);
	printk("level = %d\n", GET_TOUCHPAD_SCL2);
	OT_HAL_SCL_IN_MODE();
	udelay(2000);
	printk("level = %d\n", GET_TOUCHPAD_SCL2);

	OT_HAL_SCL_OUT_MODE();
	OT_HAL_I2C_SCL_LO();
	udelay(2000);
	printk("level = %d\n", GET_TOUCHPAD_SCL2);
	OT_HAL_SCL_IN_MODE();
	udelay(2000);
	printk("level = %d\n", GET_TOUCHPAD_SCL2);

#endif	
}

// *****************************************************************************
// This is a function to Read the OneTouch DATA Registers
//
// Functions Name:
//  * OT_ReadDataReg()
//
// Inputs:
//  * None
//
// Outputs:
//  * The Error Code (or success code). "Refer to SynaOT.h"
//
// Dependencies:
//  * OT_ReadI2C();
//  * OT_WriteI2C();
//
// Note:	All dependencies are hardware dependent and implemented in the
//			Hardware Abstraction Layer (HAL) of the host application code
// *****************************************************************************


OT_U8 OT_ReadDataReg(OT_U8 pBuffer[])
{
	
//	Read the data registers
//  OT_ReadI2C assumes the ReadAddress is preset

	if(OT_ReadI2C(OT_ADDR,pBuffer,OT_NUM_DATA_REG_BYTES) == OT_SUCCESS)	
		return OT_SUCCESS;		

	return OT_Init();		// Re-initialize OneTouch Device if Reading
							// of Data Registers failed
}
