///////////////////////////////////////////////////////////////////////////////
//! \addtogroup ddi_clocks
//! @{
//
// Copyright (c) 2004-2005 SigmaTel, Inc.
//
//! \file ddi_clocks.h
//! \brief Contains header data for the Clocks Device Driver subsystem.
///////////////////////////////////////////////////////////////////////////////
#ifndef _DDI_CLOCKS_H
#define _DDI_CLOCKS_H

// This is here to temporarily fix an include error in os_pmi_report_power_config.c
// This needs to be removed once this file is added to the file.
//#include "hw_power.h"

/////////////////////////////////////////////////////////////////////////////////
// Definitions
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Externs
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Prototypes
/////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////

//! \brief Hardware clocks memory structure
//!
//! Stores the frequency of each hardware clock
typedef struct _ddi_clocks_Clocks_t
{
    //! \brief CPU clock freqency
    uint32_t Pclk;
    //! \brief HBUS clock freqency
    uint32_t Hclk;
    //! \brief XBUS clock freqency
    uint32_t Xclk;
    //! \brief EMI clock freqency
    uint32_t EmiClk;
    //! \brief SSP clock freqency
    uint32_t SspClk;
    //! \brief GPMI clock freqency
    uint32_t GpmiClk;
    //! \brief IR clock freqency
    uint32_t IrClk;
    //! \brief IR oversample clock freqency
    uint32_t IrovClk;
    //! \brief LCD (PIX) clock freqency
    uint32_t PixClk;
    //! \brief ref_cpu PLL clock freqency
    uint32_t ref_cpu;
    //! \brief ref_emi PLL clock freqency
    uint32_t ref_emi;
    //! \brief ref_io PLL clock freqency
    uint32_t ref_io;
    //! \brief ref_io display (PIX) clock freqency
    uint32_t ref_pix;
} ddi_clocks_Clocks_t;
extern ddi_clocks_Clocks_t g_CurrentClockFreq;


///////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////
//! \brief Converts the MHz freq to kHz.  kHz is used by all ddi_clock freq drivers
#define CLK_FREQ_MHz_TO_kHz(v) (v * 1000)

///////////////////////////////////////////////////////////////////////////////
// Defines
///////////////////////////////////////////////////////////////////////////////

//! \brief Value of 24MHz as kHz.
#define XTAL_24MHZ_IN_KHZ 24000
//! \brief Value of 24Mhz in Hz.
#define XTAL_24MHZ 24000000
//! \brief Value of 480MHz as kHz.
#define PLL_480MHZ_IN_KHZ 480000
//! \brief Value of 480Mhz in Hz.
#define PLL_480MHZ 480000000
//! \brief Value of 320MHz as kHz.
#define PLL_320MHZ_IN_KHZ 320000
//! \brief Value of 320Mhz in Hz.
#define PLL_320MHZ 320000000
//! \brief Maximum PLL frequeny in kHz.
#define MAX_PLL_KHZ 480000
//! \brief Minimum PLL frequncy in Khz allowed by SDK.
#define MIN_PLL_KHZ 24000
//! \brief Threshold frequency where the PLL turns on and off.
#define PLL_THRESHOLD_KHZ 24000
//! \brief The constant value in the PFD calculation.
#define PFD_DIV_CONSTANT 18
//! \brief Minimum divider value for Phase Fractional Dividers (PFD).
#define MIN_PFD_VALUE 18
//! \brief Maximum divider value for Phase Fractional Dividers (PFD).
#define MAX_PFD_VALUE 35
//! \brief Minimum frequency that will be generated by PLL.
#define MIN_PFD_FREQ_KHZ 246857
//! \brief Maximum frequency that will be generated by PLL.
#define MAX_PFD_FREQ_KHZ 480000
//! \brief Product of maximum PLL and minimum PFD value used in calculations
#define PFD_CONSTANT (MAX_PLL_KHZ * MIN_PFD_VALUE)
//! \brief Crystal divider to achieve 24MHz
#define DIVIDER_24MHZ 1
//! \brief TBD
#define HCLK_THRESHOLD 100000000
//! \brief TBD
#define HCLK_DIV_1 1
//! \brief TBD
#define HCLK_DIV_2 2
//! \brief Maximum CPU clock frequency allowed.
#define MAX_PCLK 360000
//! \brief Minimum CPU clock frequency allowed.
#define MIN_PCLK 1000
//! \brief Maximum CPU clock frequency allowed in MHz.
#define MAX_PCLK_MHZ 360
//! \brief Maximum HBUS clock divider allowed.
#define MAX_HCLK_DIV 31
//! \brief Minimum HBUS clock divider allowed.
#define MIN_HCLK_DIV 1
//! \brief Maximum EMI clock freqquency allowed.
#define MAX_EMICLK 480000
//! \brief Minimum EMI clock frequency allowed.
#define MIN_EMICLK 1500
//! \brief Maximum XBUS clock frequency allowed.
#define MAX_XCLK 24000
//! \brief Minumum XBUS clock frequency allowed. 
#define MIN_XCLK 23
//! \brief Maximum IR clock divider allowed.
#define MAX_IR_DIV 768
//! \brief Minimum IR clock divider allowed.
#define MIN_IR_DIV 5
//! \brief Maximum IR oversample clock divider allowed.
#define MAX_IROV_DIV 260
//! \brief Minimum IR oversample clock divider allowed. 
#define MIN_IROV_DIV 4
//! \brief Maximum display clock frequency allowed.
#define MAX_PIXCLK 120000
//! \brief Minimum display clock frequency allowed.
#define MIN_PIXCLK 1000
//! \brief Minimum integer divider for default cases.  
#define MIN_INT_DIV 1

///////////////////////////////////////////////////////////////////////////////
// Enumerates
///////////////////////////////////////////////////////////////////////////////
//! \brief Enumerates the reference signals from the PLL
typedef enum _ddi_clocks_pll_ref_clks_t
{
    //! \brief ref_cpu signal for CPU clock
    PLL_REF_CPU,
    //! \brief ref_emi signal for EMI clock
    PLL_REF_EMI,
    //! \brief ref_io signal for SSP, GPMI, and IR/IROV clocks
    PLL_REF_IO,
    //! \brief ref_pix signal for display clock
    PLL_REF_PIX
} ddi_clocks_pll_ref_clks_t;

//! \brief Bitmasks for the possible clients of the PLL.  
typedef enum _ddi_clocks_PllClients_t
{
    PCLK        = 0x0001,
    EMICLK      = 0x0002,
    SSPCLK      = 0x0004,
    GPMICLK     = 0x0008,
    IROVCLK     = 0x0010,
    PIXCLK      = 0x0020,
    SAIFCLK     = 0x0040,
    SPDIFCLK    = 0x0080,
    USB         = 0x0100,
    APPLICATION = 0x0200,
    DCDCFREQCLK = 0x0400
} ddi_clocks_PllClients_t;

///////////////////////////////////////////////////////////////////////////////
// Prototypes
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the CPU and HBUS clock frequencies 
//!
//! \fntype Function
//!
//! This function will set the Pclk frequency as close as possible to the requested
//! frequency.  The 24MHz crystal will be used for speeds lower than 24MHz. For
//! speeds greater than 24Mhz, the ref_cpu clock from the PLL will be used to
//! generate the clock.  The ref_cpu's PFD, and the Pclk's dividers may all be changed.
//! The Hclk divider will be set and its speed will be a ratio of Pclk.
//!
//! \param[in] pu32ReqFreq - requested Pclk frequency in kHz
//! \param[in] u32HclkDiv - PCLK to HCLK integer ratio
//!
//! \param[out] pu32ReqFreq - actual kHz frequency Pclk was set to
//!
//! \retval ERROR_DDI_CLOCKS_INVALID_PCLK_FREQ - Pclk range exceeded
//! \retval SUCCESS 
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetPclkHclk(uint32_t* u32ReqFreq, uint32_t u32HclkDiv);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the current CPU clock frequency in kHz 
//!
//! \fntype Function
//!
//! \retval current Pclk frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetPclk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the current HBUS clock frequency in kHz 
//!
//! \fntype Function
//!
//! \retval current Hclk frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetHclk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the current HBUS clock auto-slow frequency in kHz 
//!
//! \fntype Function
//!
//! \retval current Hclk auto-slow frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetHclkSlow(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the EMI clock frequency 
//!
//! \fntype Function
//!
//! This function will set the EmiClk frequency as close as possible to the requested
//! frequency.  The 24MHz crystal will be used for speeds lower than 24MHz. For
//! speeds greater than 24Mhz, the ref_emi clock from the PLL will be used to
//! generate the clock.  The ref_emi's PFD, and the EmiClk's dividers may all be changed.
//!
//! \param[in] pu32ReqFreq - requested EmiClk frequency
//!
//! \param[out] pu32ReqFreq - actual frequency EmiClk was set to
//!
//! \retval ERROR_DDI_CLOCKS_INVALID_EMICLK_FREQ - EmiClk range exceeded
//! \retval SUCCESS 
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetEmiClk(uint32_t* u32ReqFreq);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the EMI clock frequency
//!
//! \fntype Function
//!
//! \retval EmiClk frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetEmiClk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the XBUS clock frequency  
//!
//! \fntype Function
//!
//! This function will set the Xclk frequency as close as possible to the requested
//! frequency.  The 24MHz crystal will be always be used as the source.  The maximum
//! frequency will be 24Mhz and the lowest will be 1kHz.
//!
//! \param[in] pu32ReqFreq - requested Xclk frequency in kHz (1kHz to 24MHz range)
//!
//! \param[out] pu32ReqFreq - actual kHz frequency Xclk was set to
//!
//! \retval ERROR_DDI_CLOCKS_INVALID_XCLK_FREQ - Xclk range exceeded
//! \retval SUCCESS 
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetXclk(uint32_t* u32Freq);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the XBUS clock frequency
//!
//! \fntype Function
//!
//! \retval XBUS clock frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetXclk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the SSP clock frequency
//!
//! \fntype Function
//!
//! This function will set the SSP clock divider and possibly the ref_io clock
//! If bChangeRefIo is TRUE, the ref_io clock will be changed so the SSP clock
//! frequency will be as close as possible to the requested frequency.  The ref_io
//! PFD and the SSP clock divider will possibly change.  When bChangeRefIo is FALSE,
//! the function will use the current ref_io speed and only change the SSP clock 
//! divider to get as close as possible to the requested frequency.
//!
//! \param[in] u32Freq - The requested SSP clock frequency
//! \param[in] bChangeRefIo - TRUE to allow ref_io clock to change.  
//!                           FALSE to use current ref_io
//!
//! \param[out] u32Freq - The actual frequency the SSP clock was set to
//!
//! \retval ERROR_DDI_CLOCKS_GENERAL - Do not request zero clock frequencies
//! \retval SUCCESS
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetSspClk(uint32_t* u32ReqFreq, bool bChangeRefIo);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the SSP clock frequency
//!
//! \fntype Function
//!
//! \retval SspClk frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetSspClk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the GPMI clock to the given frequency
//!
//! \fntype Function
//!
//! This function will set the GPMI clock divider and possibly the ref_io clock
//! If bChangeRefIo is TRUE, the ref_io clock will be changed so the GPMI clock
//! frequency will be as close as possible to the requested frequency.  The ref_io
//! PFD and the GPMI clock divider will possibly change.  When bChangeRefIo is FALSE,
//! the function will use the current ref_io speed and only change the GPMI clock 
//! divider to get as close as possible to the requested frequency.
//!
//! \param[in] u32Freq - The requested GPMI clock frequency
//! \param[in] bChangeRefIo - TRUE to allow ref_io clock to change.  
//!                           FALSE to use current ref_io
//!
//! \param[out] u32Freq - The actual frequency the GPMI clock was set to
//!
//! \retval ERROR_DDI_CLOCKS_GENERAL - Do not request zero clock frequencies
//! \retval SUCCESS
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetGpmiClk(uint32_t* u32ReqFreq, bool bChangeRefIo);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the GPMI clock frequency
//!
//! \fntype Function
//!
//! \retval GPMI clock frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetGpmiClk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the IR and IR overdrive (IROV) clock to the given frequency
//!
//! \fntype Function
//!
//! This function will set the IR and IROV clock divider and possibly the ref_io clock
//! If bChangeRefIo is TRUE, the ref_io clock will be changed so the IR clock
//! frequency will be as close as possible to the requested frequency.  The IROV 
//! clock is divided off of the IR clock.  The ref_io PFD, IR, and IROV clock 
//! divider will possibly change.  When bChangeRefIo is FALSE, the function will 
//! use the current ref_io speed and only change the GPMI clock divider to get 
//! as close as possible to the requested frequency.
//!
//! \param[in] u32IrFreq - The requested IR clock frequency
//! \param[in] u32IrovFreq - The requested IROV clock frequency
//! \param[in] bChangeRefIo - TRUE to allow ref_io clock to change.  
//!                           FALSE to use current ref_io
//!
//! \param[out] u32IrFreq - The actual frequency the IR clock was set to
//! \param[out] u32IrovFreq - The actual frequency the IROV clock was set to
//!
//! \retval ERROR_DDI_CLOCKS_GENERAL - Do not request zero clock frequencies
//! \retval SUCCESS

/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetIrClk(uint32_t* u32IrFreq_kHz, uint32_t* u32IrovFreq_kHz, bool bChangeRefIo);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the IrClk frequency
//!
//! \fntype Function
//!
//! \retval IrClk frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetIrClk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the IrovClk frequency
//!
//! \fntype Function
//!
//! \retval IrovClk frequency in kHz
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetIrovClk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the Pix (LCDIF) clock
//!
//! \fntype Function
//!
//! \param[in] u32Freq = Requested clock frequency in kHz
//! \param[in] bStrict = TRUE - Pix Clock will always try to be exact
//!
//! \param[out] u32Freq = Actual frequency the clock was set to
//!
//! \retval SUCCESS
//! \retval ERROR_DDI_CLOCKS_INVALID_PIXCLK_FREQ - frequency requested out of range
//!
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetPixClk(uint32_t* u32ReqFreq);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the Pix (LCDIF) clock
//!
//! \fntype Function
//!
//! \retval Pix clock frequency in kHz
//!
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetPixClk(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the SAIF clock
//!
//! \fntype Function
//!
//! \param[in] u32Freq = New frequency in kHz
//!
//! \retval SUCCESS
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetSaifClk(uint32_t* u32ReqFreq);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the PCMSPDIF clock
//!
//! \fntype Function
//!
//! \param[in] u32Freq = New frequency in kHz
//!
//! \retval SUCCESS
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetSpdifClk(uint32_t* u32ReqFreq);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Gates/ungates the 24MHz clock to the UART
//!
//! \fntype Function
//!
//! \param[in] bClkGate = TRUE to gate the clock, FALSE to ungate
//!
/////////////////////////////////////////////////////////////////////////////////
void ddi_clocks_SetUartClkGate(bool bClkGate);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Gates/ungates the 24MHz clock to the digital filter
//!
//! \fntype Function
//!
//! \param[in] bClkGate = TRUE to gate the clock, FALSE to ungate
//!
/////////////////////////////////////////////////////////////////////////////////
void ddi_clocks_SetDigFiltClkGate(bool bClkGate);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Gates/ungates the 24MHz clock to the PWM
//!
//! \fntype Function
//!
//! \param[in] bClkGate = TRUE to gate the clock, FALSE to ungate
//!
/////////////////////////////////////////////////////////////////////////////////
void ddi_clocks_SetPwmClkGate(bool bClkGate);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Gates/ungates the 24MHz clock to the DRI
//!
//! \fntype Function
//!
//! \param[in] bClkGate = TRUE to gate the clock, FALSE to ungate
//!
/////////////////////////////////////////////////////////////////////////////////
void ddi_clocks_SetDriClkGate(bool bClkGate);
    
/////////////////////////////////////////////////////////////////////////////////
//! \brief Gates/ungates the 1MHz clock to the digital control
//!
//! \fntype Function
//!
//! \param[in] bClkGate = TRUE to gate the clock, FALSE to ungate
//!
/////////////////////////////////////////////////////////////////////////////////
void ddi_clocks_SetDigCtrlClkGate(bool bClkGate);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Gates/ungates the 32kHz clock to the timer/rotary encoder block
//!
//! \fntype Function
//!
//! \param[in] bClkGate = TRUE to gate the clock, FALSE to ungate
//!
/////////////////////////////////////////////////////////////////////////////////
void ddi_clocks_SetTimrotClkGate(bool bClkGate);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Bypass the reference clock from the PLL for the ref_cpu 
//!
//! \fntype Function
//!
//! \param[in] bBypass = TRUE to bypass PLL, use 24MHz; FALSE use PLL signal
//!
//! \retval SUCCESS - bypass operatiom successful
//! \retval ERROR_ - HW level error
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_BypassRefCpu(bool bBypass);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Bypass the reference clock from the PLL for the ref_emi 
//!
//! \fntype Function
//!
//! \param[in] bBypass = TRUE to bypass PLL, use 24MHz; FALSE use PLL signal
//!
//! \retval SUCCESS - bypass operatiom successful
//! \retval ERROR_ - HW level error
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_BypassRefEmi(bool bBypass);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Bypass the reference clock from the PLL for the ref_io signal to the SSP
//!
//! \fntype Function
//!
//! \param[in] bBypass = TRUE to bypass PLL, use 24MHz, FALSE use PLL signal
//!
//! \retval SUCCESS - bypass operatiom successful
//! \retval ERROR_ - HW level error
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_BypassRefIoSsp(bool bBypass);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Bypass the reference clock from the PLL for the ref_io signal to the GPMI
//!
//! \fntype Function
//!
//! \param[in] bBypass = TRUE to bypass PLL, use 24MHz, FALSE use PLL signal
//!
//! \retval SUCCESS - bypass operatiom successful
//! \retval ERROR_ - HW level error
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_BypassRefIoGpmi(bool bBypass);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Bypass the reference clock from the PLL for the ref_io signal to the IR
//!
//! \fntype Function
//!
//! \param[in] bBypass = TRUE to bypass PLL, use 24MHz, FALSE use PLL signal
//!
//! \retval SUCCESS - bypass operatiom successful
//! \retval ERROR_ - HW level error
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_BypassRefIoIr(bool bBypass);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Bypass the reference clock from the PLL for the ref_pix signal to the LCD
//!
//! \fntype Function
//!
//! \param[in] bBypass = TRUE to bypass PLL, use 24MHz, FALSE use PLL signal
//!
//! \retval SUCCESS - bypass operatiom successful
//! \retval ERROR_ - HW level error
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_BypassRefPix(bool bBypass);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Get the bypass status of ref_cpu signal to Pclk
//!
//! \fntype Function
//!
//! \retval TRUE - ref_cpu bypassed, ref_xtal is source clock
//! \retval FALSE - ref_cpu is source clock
/////////////////////////////////////////////////////////////////////////////////
bool ddi_clocks_GetBypassRefCpu(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Get the bypass status of ref_emi signal
//!
//! \fntype Function
//!
//! \retval TRUE - ref_emi bypassed, ref_xtal is source clock
//! \retval FALSE - ref_emi is source clock
/////////////////////////////////////////////////////////////////////////////////
bool ddi_clocks_GetBypassRefEmi(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Get the bypass status of ref_pix signal
//!
//! \fntype Function
//!
//! \retval TRUE - ref_pix bypassed, ref_xtal is source clock
//! \retval FALSE - ref_pix is source clock
/////////////////////////////////////////////////////////////////////////////////
bool ddi_clocks_GetBypassRefPix(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Get the bypass status of ref_io signal for SspClk
//!
//! \fntype Function
//!
//! \retval TRUE - ref_io bypassed, ref_xtal is source clock
//! \retval FALSE - ref_io is source clock
/////////////////////////////////////////////////////////////////////////////////
bool ddi_clocks_GetBypassRefIoSsp(void);


/////////////////////////////////////////////////////////////////////////////////
//! \brief Get the bypass status of ref_io signal for GpmiClk
//!
//! \fntype Function
//!
//! \retval TRUE - ref_io bypassed, ref_xtal is source clock
//! \retval FALSE - ref_io is source clock
/////////////////////////////////////////////////////////////////////////////////
bool ddi_clocks_GetBypassRefIoGpmi(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Get the bypass status of ref_io signal for IrClk
//!
//! \fntype Function
//!
//! \retval TRUE - ref_io bypassed, ref_xtal is source clock
//! \retval FALSE - ref_io is source clock
/////////////////////////////////////////////////////////////////////////////////
bool ddi_clocks_GetBypassRefIoIr(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the current PLL clock frequency 
//!
//! \fntype Function
//!
//! \retval Always 480Mhz since PLL does not change on STMP37xx
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetPll(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the current PLL status
//!
//! \fntype Function
//!
//! \retval TRUE if powered, FALSE if off.
/////////////////////////////////////////////////////////////////////////////////
bool ddi_clocks_GetPllStatus(void);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Sets the software limited maximum PLL frequency 
//!
//! \fntype Function
//!
//! \param[in] u32MaxFreq Maximum allowed PLL frequency in kHz.
//!
//! \retval SUCCESS
//! \retval hw level error code
/////////////////////////////////////////////////////////////////////////////////
RtStatus_t ddi_clocks_SetMaxPllRefFreq(uint32_t u32MaxFreq);

/////////////////////////////////////////////////////////////////////////////////
//! \brief Returns the current software limited maximum PLL frequency.
//!
//! \fntype Function
//!
//! \retval Software limited maximum PLL frequency in kHz.
/////////////////////////////////////////////////////////////////////////////////
uint32_t ddi_clocks_GetMaxPllRefFreq(void);

void ddi_clocks_KeepPllPowered(bool bPowered);
bool ddi_clocks_PllPoweredForApp(void);
uint32_t ddi_clocks_GetPllRefClkFreq(ddi_clocks_pll_ref_clks_t RefClk);
void ddi_clocks_ClockUsingPll(ddi_clocks_PllClients_t eClient, bool bPllInUse);
bool ddi_clocks_PowerOffPll(void);
RtStatus_t ddi_clocks_UsbPowerOnPll(bool bPowerOn);

#endif  // _DDI_CLOCKS_H
///////////////////////////////////////////////////////////////////////////////
// End of file
///////////////////////////////////////////////////////////////////////////////
//! @}
