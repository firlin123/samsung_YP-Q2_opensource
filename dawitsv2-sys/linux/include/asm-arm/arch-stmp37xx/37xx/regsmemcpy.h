////////////////////////////////////////////////////////////////////////////////
//
// Filename: regsmemcpy.h
//
// Description: PIO Registers for MEMCPY interface
//
// Xml Revision: 1.18
//
////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) SigmaTel, Inc. Unpublished
//
// SigmaTel, Inc.
// Proprietary & Confidential
//
// This source code and the algorithms implemented therein constitute
// confidential information and may compromise trade secrets of SigmaTel, Inc.
// or its associates, and any unauthorized use thereof is prohibited.
//
////////////////////////////////////////////////////////////////////////////////
//
// WARNING!  THIS FILE IS AUTOMATICALLY GENERATED FROM XML.
//                DO NOT MODIFY THIS FILE DIRECTLY.
//
////////////////////////////////////////////////////////////////////////////////
//
// The following naming conventions are followed in this file.
//      XX_<module>_<regname>_<field>
//
// XX specifies the define / macro class
//      HW pertains to a register
//      BM indicates a Bit Mask
//      BF indicates a Bit Field macro
//
// <module> is the hardware module name which can be any of the following...
//      USB20 (Note when there is more than one copy of a given module, the 
//      module name includes a number starting from 0 for the first instance 
//      of that module)
//
// <regname> is the specific register within that module
//
// <field> is the specific bitfield within that <module>_<register>
//
// We also define the following...
//      hw_<module>_<regname>_t is typedef of anonymous union
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _REGSMEMCPY_H
#define _REGSMEMCPY_H  1

#include "regs.h"


////////////////////////////////////////////////////////////////////////////////
//// HW_MEMCPY_CTRL - Memory Copy Device Control and Status Register
////////////////////////////////////////////////////////////////////////////////

#ifndef __LANGUAGE_ASM__
typedef union
{
    reg32_t  U;
    struct
    {
        reg16_t  XFER_SIZE;
        unsigned BURST      :  1;
        unsigned RSRVD1     : 12;
        unsigned PRESENT    :  1;
        unsigned CLKGATE    :  1;
        unsigned SFTRST     :  1;
    };
} hw_memcpy_ctrl_t;
#endif


//
// constants & macros for entire HW_MEMCPY_CTRL register
//

#define HW_MEMCPY_CTRL_ADDR      0xE0014000
#define HW_MEMCPY_CTRL_SET_ADDR  0xE0014004
#define HW_MEMCPY_CTRL_CLR_ADDR  0xE0014008
#define HW_MEMCPY_CTRL_TOG_ADDR  0xE001400C

#ifndef __LANGUAGE_ASM__
#define HW_MEMCPY_CTRL          (*(volatile hw_memcpy_ctrl_t *) HW_MEMCPY_CTRL_ADDR)
#define HW_MEMCPY_CTRL_RD()     (HW_MEMCPY_CTRL.U)
#define HW_MEMCPY_CTRL_WR(v)    (HW_MEMCPY_CTRL.U = (v))
#define HW_MEMCPY_CTRL_SET(v)   ((*(volatile reg32_t *) HW_MEMCPY_CTRL_SET_ADDR) = (v))
#define HW_MEMCPY_CTRL_CLR(v)   ((*(volatile reg32_t *) HW_MEMCPY_CTRL_CLR_ADDR) = (v))
#define HW_MEMCPY_CTRL_TOG(v)   ((*(volatile reg32_t *) HW_MEMCPY_CTRL_TOG_ADDR) = (v))
#endif


//
// constants & macros for individual HW_MEMCPY_CTRL bitfields
//

#define BP_MEMCPY_CTRL_SFTRST      31
#define BM_MEMCPY_CTRL_SFTRST      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_MEMCPY_CTRL_SFTRST(v)   ((((reg32_t) v) << 31) & BM_MEMCPY_CTRL_SFTRST)
#else
#define BF_MEMCPY_CTRL_SFTRST(v)   (((v) << 31) & BM_MEMCPY_CTRL_SFTRST)
#endif

#ifndef __LANGUAGE_ASM__
#define BW_MEMCPY_CTRL_SFTRST(v)   BF_CS1(MEMCPY_CTRL, SFTRST, v)
#endif

#define BV_MEMCPY_CTRL_SFTRST__RUN    0x0
#define BV_MEMCPY_CTRL_SFTRST__RESET  0x1


//---

#define BP_MEMCPY_CTRL_CLKGATE      30
#define BM_MEMCPY_CTRL_CLKGATE      0x40000000

#define BF_MEMCPY_CTRL_CLKGATE(v)   (((v) << 30) & BM_MEMCPY_CTRL_CLKGATE)

#ifndef __LANGUAGE_ASM__
#define BW_MEMCPY_CTRL_CLKGATE(v)   BF_CS1(MEMCPY_CTRL, CLKGATE, v)
#endif

#define BV_MEMCPY_CTRL_CLKGATE__RUN      0x0
#define BV_MEMCPY_CTRL_CLKGATE__NO_CLKS  0x1


//---

#define BP_MEMCPY_CTRL_PRESENT      29
#define BM_MEMCPY_CTRL_PRESENT      0x20000000

#define BF_MEMCPY_CTRL_PRESENT(v)   (((v) << 29) & BM_MEMCPY_CTRL_PRESENT)

#define BV_MEMCPY_CTRL_PRESENT__UNAVAILABLE  0x0
#define BV_MEMCPY_CTRL_PRESENT__AVAILABLE    0x1


//---

#define BP_MEMCPY_CTRL_BURST      16
#define BM_MEMCPY_CTRL_BURST      0x00010000

#define BF_MEMCPY_CTRL_BURST(v)   (((v) << 16) & BM_MEMCPY_CTRL_BURST)

#ifndef __LANGUAGE_ASM__
#define BW_MEMCPY_CTRL_BURST(v)   BF_CS1(MEMCPY_CTRL, BURST, v)
#endif


//---

#define BP_MEMCPY_CTRL_XFER_SIZE      0
#define BM_MEMCPY_CTRL_XFER_SIZE      0x0000FFFF

#define BF_MEMCPY_CTRL_XFER_SIZE(v)   (((v) << 0) & BM_MEMCPY_CTRL_XFER_SIZE)

#ifndef __LANGUAGE_ASM__
#define BW_MEMCPY_CTRL_XFER_SIZE(v)   (HW_MEMCPY_CTRL.XFER_SIZE = (v))
#endif


////////////////////////////////////////////////////////////////////////////////
//// HW_MEMCPY_DATA - MEMCPY device DMA read and write data registers
////////////////////////////////////////////////////////////////////////////////

#ifndef __LANGUAGE_ASM__
typedef union
{
    reg32_t  U;
    struct
    {
        reg32_t  DATA;
    };
} hw_memcpy_data_t;
#endif


//
// constants & macros for entire HW_MEMCPY_DATA register
//

#define HW_MEMCPY_DATA_ADDR      0xE0014010
#define HW_MEMCPY_DATA_SET_ADDR  0xE0014014
#define HW_MEMCPY_DATA_CLR_ADDR  0xE0014018
#define HW_MEMCPY_DATA_TOG_ADDR  0xE001401C

#ifndef __LANGUAGE_ASM__
#define HW_MEMCPY_DATA          (*(volatile hw_memcpy_data_t *) HW_MEMCPY_DATA_ADDR)
#define HW_MEMCPY_DATA_RD()     (HW_MEMCPY_DATA.U)
#define HW_MEMCPY_DATA_WR(v)    (HW_MEMCPY_DATA.U = (v))
#define HW_MEMCPY_DATA_SET(v)   ((*(volatile reg32_t *) HW_MEMCPY_DATA_SET_ADDR) = (v))
#define HW_MEMCPY_DATA_CLR(v)   ((*(volatile reg32_t *) HW_MEMCPY_DATA_CLR_ADDR) = (v))
#define HW_MEMCPY_DATA_TOG(v)   ((*(volatile reg32_t *) HW_MEMCPY_DATA_TOG_ADDR) = (v))
#endif


//
// constants & macros for individual HW_MEMCPY_DATA bitfields
//

#define BP_MEMCPY_DATA_DATA      0
#define BM_MEMCPY_DATA_DATA      0xFFFFFFFF

#ifndef __LANGUAGE_ASM__
#define BF_MEMCPY_DATA_DATA(v)   ((reg32_t) v)
#else
#define BF_MEMCPY_DATA_DATA(v)   (v)
#endif

#ifndef __LANGUAGE_ASM__
#define BW_MEMCPY_DATA_DATA(v)   (HW_MEMCPY_DATA.DATA = (v))
#endif


////////////////////////////////////////////////////////////////////////////////
//// HW_MEMCPY_DEBUG - MEMCPY Device Debug Register
////////////////////////////////////////////////////////////////////////////////

#ifndef __LANGUAGE_ASM__
typedef union
{
    reg32_t  U;
    struct
    {
        unsigned READ_STATE   :  2;
        unsigned WRITE_STATE  :  2;
        unsigned RSVD0        : 20;
        unsigned SRC_DMA_REQ  :  1;
        unsigned SRC_KICK     :  1;
        unsigned RSVD1        :  2;
        unsigned DST_DMA_REQ  :  1;
        unsigned DST_KICK     :  1;
        unsigned DST_END_CMD  :  1;
        unsigned RSVD2        :  1;
    };
} hw_memcpy_debug_t;
#endif


//
// constants & macros for entire HW_MEMCPY_DEBUG register
//

#define HW_MEMCPY_DEBUG_ADDR      0xE0014020

#ifndef __LANGUAGE_ASM__
#define HW_MEMCPY_DEBUG          (*(volatile hw_memcpy_debug_t *) HW_MEMCPY_DEBUG_ADDR)
#define HW_MEMCPY_DEBUG_RD()     (HW_MEMCPY_DEBUG.U)
#endif


//
// constants & macros for individual HW_MEMCPY_DEBUG bitfields
//

#define BP_MEMCPY_DEBUG_DST_END_CMD      30
#define BM_MEMCPY_DEBUG_DST_END_CMD      0x40000000

#define BF_MEMCPY_DEBUG_DST_END_CMD(v)   (((v) << 30) & BM_MEMCPY_DEBUG_DST_END_CMD)


//---

#define BP_MEMCPY_DEBUG_DST_KICK      29
#define BM_MEMCPY_DEBUG_DST_KICK      0x20000000

#define BF_MEMCPY_DEBUG_DST_KICK(v)   (((v) << 29) & BM_MEMCPY_DEBUG_DST_KICK)


//---

#define BP_MEMCPY_DEBUG_DST_DMA_REQ      28
#define BM_MEMCPY_DEBUG_DST_DMA_REQ      0x10000000

#define BF_MEMCPY_DEBUG_DST_DMA_REQ(v)   (((v) << 28) & BM_MEMCPY_DEBUG_DST_DMA_REQ)


//---

#define BP_MEMCPY_DEBUG_SRC_KICK      25
#define BM_MEMCPY_DEBUG_SRC_KICK      0x02000000

#define BF_MEMCPY_DEBUG_SRC_KICK(v)   (((v) << 25) & BM_MEMCPY_DEBUG_SRC_KICK)


//---

#define BP_MEMCPY_DEBUG_SRC_DMA_REQ      24
#define BM_MEMCPY_DEBUG_SRC_DMA_REQ      0x01000000

#define BF_MEMCPY_DEBUG_SRC_DMA_REQ(v)   (((v) << 24) & BM_MEMCPY_DEBUG_SRC_DMA_REQ)


//---

#define BP_MEMCPY_DEBUG_WRITE_STATE      2
#define BM_MEMCPY_DEBUG_WRITE_STATE      0x0000000C

#define BF_MEMCPY_DEBUG_WRITE_STATE(v)   (((v) << 2) & BM_MEMCPY_DEBUG_WRITE_STATE)


//---

#define BP_MEMCPY_DEBUG_READ_STATE      0
#define BM_MEMCPY_DEBUG_READ_STATE      0x00000003

#define BF_MEMCPY_DEBUG_READ_STATE(v)   (((v) << 0) & BM_MEMCPY_DEBUG_READ_STATE)


#endif // _REGSMEMCPY_H

////////////////////////////////////////////////////////////////////////////////
